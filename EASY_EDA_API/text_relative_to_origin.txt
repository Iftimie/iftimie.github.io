(function () {
  try {
    if (typeof api !== "function") {
      alert("api() not available");
      return;
    }

    const src = api("getSource", { type: "json" });

    // ---------- helpers ----------
    function firstPointFromObj(o) {
      // Your build uses pointArr: [{x,y}, ...]
      if (o && Array.isArray(o.pointArr) && o.pointArr.length > 0) {
        const pt = o.pointArr[0];
        if (pt && typeof pt.x === "number" && typeof pt.y === "number") {
          return { x: pt.x, y: pt.y };
        }
      }
      // Some objects store points as strings; try best-effort
      const s = o && (o.pointStr || o.pathStr);
      if (typeof s === "string") {
        const nums = s.match(/-?\d+(\.\d+)?/g);
        if (nums && nums.length >= 2) return { x: Number(nums[0]), y: Number(nums[1]) };
      }
      return null;
    }

    function pickLikelyOutlineTrack(source) {
      const tracks = source.TRACK || {};
      const keys = Object.keys(tracks);
      if (!keys.length) return null;

      // Heuristic: outline tends to be on a specific layerid
      // and consists of longer tracks with empty net.
      const layerScore = new Map();

      for (const k of keys) {
        const t = tracks[k];
        if (!t || t.layerid == null) continue;

        const net = (t.net ?? t.netname ?? "");
        const pts = t.pointArr;

        // prefer tracks with multiple points and no net
        let score = 0;
        if (!net) score += 2;
        if (Array.isArray(pts) && pts.length >= 2) score += 2;
        if (Array.isArray(pts) && pts.length >= 4) score += 1;

        const lid = String(t.layerid);
        layerScore.set(lid, (layerScore.get(lid) || 0) + score);
      }

      // choose layer with highest score
      let bestLayer = null, bestScore = -Infinity;
      for (const [lid, sc] of layerScore.entries()) {
        if (sc > bestScore) { bestScore = sc; bestLayer = lid; }
      }
      if (!bestLayer) return null;

      // pick the first track on that layer that has pointArr
      for (const k of keys) {
        const t = tracks[k];
        if (t && String(t.layerid) === bestLayer && Array.isArray(t.pointArr) && t.pointArr.length) {
          return { trackKey: k, trackObj: t, layerid: bestLayer };
        }
      }
      return null;
    }

    // ---------- 1) try direct buckets if they exist ----------
    let outlineObj = null;
    let outlineWhere = null;

    // Some EasyEDA versions expose BOARDOUTLINE bucket
    if (src.BOARDOUTLINE && typeof src.BOARDOUTLINE === "object") {
      const ks = Object.keys(src.BOARDOUTLINE);
      if (ks.length) {
        outlineObj = src.BOARDOUTLINE[ks[0]];
        outlineWhere = "BOARDOUTLINE[" + ks[0] + "]";
      }
    }

    // ---------- 2) fallback: pick a likely outline TRACK ----------
    let outlineLayer = null;
    if (!outlineObj) {
      const pick = pickLikelyOutlineTrack(src);
      if (!pick) {
        alert("Couldn't find a likely outline. (No TRACKs?)");
        return;
      }
      outlineObj = pick.trackObj;
      outlineLayer = pick.layerid;
      outlineWhere = "TRACK[" + pick.trackKey + "] (heuristic layer " + outlineLayer + ")";
    }

    const p0 = firstPointFromObj(outlineObj);
    if (!p0) {
      alert("Found outline candidate, but couldn't extract its first point.\n" + outlineWhere);
      return;
    }

    // ---------- 3) draw relative to outline first point ----------
    const gId = "gge" + Date.now();
    const markerText = "OUT0_" + gId;

    // Put text 200 units to the right and down from outline first point
    const x = p0.x ;
    const y = p0.y ;

    // Choose a visible layer:
    // If we detected an outline layer, put text on same layer as your earlier working example (10),
    // but better: reuse whatever layer the outline object is on, unless you prefer a silkscreen layer.
    const textLayer = String((outlineObj.layerid != null) ? outlineObj.layerid : (outlineLayer || 10));

    api("createShape", {
      shapeType: "TEXT",
      jsonCache: {
        gId,
        layerid: textLayer,
        x, y,
        text: markerText,
        fontSize: 20,
        rotate: 0,
        mirror: false
      }
    });

    alert(
      "Outline anchor found âœ…\n\n" +
      "From: " + outlineWhere + "\n" +
      "Outline layerid: " + (outlineObj.layerid ?? "n/a") + "\n" +
      "Outline first point: (" + p0.x + ", " + p0.y + ")\n" +
      "Placed TEXT at: (" + x + ", " + y + ")\n" +
      "Text layerid: " + textLayer + "\n\n" +
      markerText
    );

  } catch (e) {
    alert("Error: " + (e.message || e));
  }
})();
