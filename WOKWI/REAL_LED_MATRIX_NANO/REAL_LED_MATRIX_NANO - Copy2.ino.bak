#include <Arduino.h>
#include <SPI.h>

// ===================== PINS =====================
// Nano/Uno SPI pins fixed: MOSI=D11, SCK=D13
const int PIN_LATCH = 10;  // STCP / LE
const int PIN_OE_N  = 9;   // OE# (active-low)

// ===================== PANEL CONFIG =====================
static const uint8_t W = 16;
static const uint8_t H = 16;
static const uint8_t LAYERS = 5;

// Framebuffers: fb[layer][y] is a 16-bit row bitmask
volatile uint16_t fb[LAYERS][H];
static volatile uint8_t scanY = 0;

// ===================== TIMER SCANNER (ISR) =====================
// rowWord: bit y = 1
static inline uint16_t makeRowWord(uint8_t y) { return (uint16_t)1 << y; }

static inline void latchPulseFast() {
  digitalWrite(PIN_LATCH, HIGH);
  digitalWrite(PIN_LATCH, LOW);
}

ISR(TIMER1_COMPA_vect) {
  // blank while shifting
  digitalWrite(PIN_OE_N, HIGH);

  uint8_t y = scanY;
  uint16_t rowWord = makeRowWord(y);
  uint8_t sr0_byte = (uint8_t)(rowWord & 0xFF);
  uint8_t sr1_byte = (uint8_t)((rowWord >> 8) & 0xFF);

  SPI.beginTransaction(SPISettings(8000000, MSBFIRST, SPI_MODE0));

  // Daisy chain assumed:
  // MCU -> sr0 -> sr1 -> mbi0 -> mbi1 -> mbi2 -> mbi3 -> mbi4
  // Shift order must be: mbi4..mbi0, then sr1, sr0
  for (int l = (int)LAYERS - 1; l >= 0; --l) {
    uint16_t cols = fb[l][y];
    SPI.transfer((uint8_t)(cols >> 8));
    SPI.transfer((uint8_t)(cols & 0xFF));
  }

  SPI.transfer(sr1_byte);
  SPI.transfer(sr0_byte);

  SPI.endTransaction();

  latchPulseFast();
  digitalWrite(PIN_OE_N, LOW); // enable LEDs

  scanY++;
  if (scanY >= H) scanY = 0;
}

static void startScanner(uint16_t rowRateHz) {
  cli();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1  = 0;

  // prescaler 8 => 2MHz timer clock
  TCCR1B |= (1 << WGM12);  // CTC
  TCCR1B |= (1 << CS11);   // prescaler 8
  OCR1A = (uint16_t)((2000000UL / rowRateHz) - 1);

  TIMSK1 |= (1 << OCIE1A);
  sei();
}

// ===================== FB HELPERS =====================
static inline void clearAll() {
  cli();
  for (uint8_t l = 0; l < LAYERS; l++) {
    for (uint8_t y = 0; y < H; y++) fb[l][y] = 0;
  }
  sei();
}

static inline void clearLayerLocal(uint16_t out[H]) {
  for (uint8_t y = 0; y < H; y++) out[y] = 0;
}

static inline void setPixelLocal(uint16_t out[H], int x, int y) {
  if (x < 0 || x >= (int)W || y < 0 || y >= (int)H) return;
  out[y] |= (uint16_t)1 << x;
}

// Draw with a little thickness so it’s readable on 16x16
static inline void plotThick(uint16_t out[H], int x, int y, uint8_t thick) {
  setPixelLocal(out, x, y);
  if (!thick) return;
  setPixelLocal(out, x + 1, y);
  setPixelLocal(out, x - 1, y);
  setPixelLocal(out, x, y + 1);
  setPixelLocal(out, x, y - 1);
  if (thick > 1) {
    setPixelLocal(out, x + 1, y + 1);
    setPixelLocal(out, x - 1, y + 1);
    setPixelLocal(out, x + 1, y - 1);
    setPixelLocal(out, x - 1, y - 1);
  }
}

// Commit ONLY layer 4 (others off)
static void commitLayer4(const uint16_t layer4[H]) {
  cli();
  for (uint8_t y = 0; y < H; y++) fb[4][y] = layer4[y];
  for (uint8_t l = 0; l < 4; l++) for (uint8_t y = 0; y < H; y++) fb[l][y] = 0;
  sei();
}

// ===================== TIMING =====================
static inline bool everyMs(uint32_t &last, uint32_t periodMs) {
  uint32_t now = millis();
  if (now - last >= periodMs) { last = now; return true; }
  return false;
}

// ===================== 2-ARM GALAXY SPIRAL =====================
//
// We model arms as a logarithmic-ish spiral:
//   theta = rot + pitch * r
// Then point:
//   x = cx + r * cos(theta)
//   y = cy + r * sin(theta)
//
// Second arm is same but +PI (180°).
//
// On 16x16 we keep it simple and choose parameters that look good.
static void drawTwoArmSpiral(uint16_t out[H], float rotRad) {
  clearLayerLocal(out);

  const float cx = 7.5f;
  const float cy = 7.5f;

  const float rMax   = 7.5f;
  const float rStep  = 0.28f;   // was 0.35f (denser line so thin still reads well)
  const float pitch  = 1.05f;
  const uint8_t thick = 0;      // was 1 (THINNER)

  // Bright core (keep it visible)
  plotThick(out, (int)roundf(cx), (int)roundf(cy), 2);

  for (float r = 0.6f; r <= rMax; r += rStep) {
    float theta = rotRad + pitch * r;

    int x0 = (int)lroundf(cx + r * cosf(theta));
    int y0 = (int)lroundf(cy + r * sinf(theta));
    plotThick(out, x0, y0, thick);

    float theta2 = theta + 3.1415926f;
    int x1 = (int)lroundf(cx + r * cosf(theta2));
    int y1 = (int)lroundf(cy + r * sinf(theta2));
    plotThick(out, x1, y1, thick);
  }
}

static void animGalaxyLayer4() {
  static uint32_t tAnim = 0;
  static int rotDeg = 0;

  const uint32_t FRAME_MS = 100;
  const int ROT_STEP_DEG  = 5;

  if (!everyMs(tAnim, FRAME_MS)) return;

  rotDeg = (rotDeg - ROT_STEP_DEG);   // was + (ROTATE OTHER WAY)
  if (rotDeg < 0) rotDeg += 360;

  float rotRad = rotDeg * 3.1415926f / 180.0f;

  static uint16_t layer4[H];
  drawTwoArmSpiral(layer4, rotRad);
  commitLayer4(layer4);
}


// ===================== ARDUINO =====================
void setup() {
  pinMode(PIN_LATCH, OUTPUT);
  pinMode(PIN_OE_N, OUTPUT);
  digitalWrite(PIN_LATCH, LOW);
  digitalWrite(PIN_OE_N, HIGH);

  SPI.begin();
  clearAll();

  // 2000 rows/sec => 125 Hz refresh
  startScanner(2000);

  Serial.begin(115200);
}

void loop() {
  animGalaxyLayer4();
}
